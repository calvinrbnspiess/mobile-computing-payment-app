%!TEX root = ../dokumentation.tex

\chapter{Implementierung}

Dieses Kapitel beinhaltet sämtliche Implementierungen und Features in der App.
Dabei werden benutzte Libraries und Code aus der App gezeigt.

\section{App}

Hier screenshots und erklärung

\section{Transaktionshistorie}
Die Transaktionshistorie wurde komplett mithilfe von den zwei selbst entwickelten Widgets TransactionHistory und TransactionEntry implementiert.
Diese sind beide stateless, bekommen ihre Inhalte also vom MainScreen in Form eines Arrays übergeben.\\
Die TransactionHistory stellt mithilfe der take()-Funktion die ersten drei Einträge des übergebenen Arrays dar, wodurch nur die aktuellsten Transaktionen angezeigt werden.
Sofern keine Transaktionen vorhanden sind, wird ein Text dargestellt.\\
Im TransactionEntry wird ein Eintrag mit dem Zeitstempel der Transaktion, der Beschreibung und dem Betrag gerendert.
Ausgehende Transaktionen stellen negative Werte dar und werden in roter Farbe dargestellt.
Andernfalls werden die Beträge grün dargestellt.\\
Bei der Überweisung per Kreditkarte kam es zu dem Problem, dass sehr lange Beschreibungstexte abgespeichert wurden.
Um ein horizontales Überlaufen zu verhindern, wird der Text daher nach 20 Zeichen abgeschnitten.\\
Ebenfalls wurde eingebaut, dass die Zeitstempel formatiert je nach Alter als etwa „Gerade eben“, „Vor 24 Minuten“, „16:43 Uhr“ oder im Format „23.11.2023 16:00“ ausgegeben werden.
Das Verhalten wird in Abbildung \ref{fig:transactionhistory} dargestellt.

\begin{figure}[H]
  \centering
  \includegraphics{onetransaction.png}
  \includegraphics{overflowingtransaction.png}
  \includegraphics{multipletransactions.png}
  \label{fig:transactionhistory}
  \caption{Darstellung der Transaktionshistorie in verschiedenen Fällen, mit einer Transaktion, ohne Textkürzung, und mit mehreren Transaktionen.}
\end{figure}

\section{QR-Code Scanner}

Zum Erkennen und Scannen der QR-Codes wird die Library \glqq mobile\_scanner\grqq{} in der Version \glqq 3.5.2\grqq{} genutzt.
Diese arbeitet sowohl unter iOS als auch Android zuverlässig.
Die Integration findet in der \glqq qr\_code\_scan\_screen.dart\grqq{} Datei statt.
Es wird hierzu die Klasse \glqq \_QRScanScreenState\grqq{} erstellt in welcher die Funktionen der Library implementiert werden.
Unter anderem ist hier die Steuerung der Kamera, das Wechseln zwischen Front- und Rückkamera möglich und die Steuerung des Kamerablitzes möglich.

\begin{lstlisting}[caption=Kamerasteuerung, label=cam_ctrl]
	appBar: PayeroHeader(showBackButton: true, actions: [
        IconButton(
          color: Colors.white,
          icon: ValueListenableBuilder(
            valueListenable: cameraController.torchState,
            builder: (context, state, child) {
              switch (state as TorchState) {
                case TorchState.off:
                  return const Icon(Icons.flash_off, color: Colors.grey);
                case TorchState.on:
                  return const Icon(Icons.flash_on, color: Colors.yellow);
              }
            },
          ),
          iconSize: 32.0,
          onPressed: () => cameraController.toggleTorch(),
        ),
        IconButton(
          color: Colors.white,
          icon: ValueListenableBuilder(
            valueListenable: cameraController.cameraFacingState,
            builder: (context, state, child) {
              switch (state as CameraFacing) {
                case CameraFacing.front:
                  return const Icon(Icons.camera_front, color: Colors.grey);
                case CameraFacing.back:
                  return const Icon(Icons.camera_rear, color: Colors.grey);
              }
            },
          ),
          iconSize: 32.0,
          onPressed: () => cameraController.switchCamera(),
        )
      ])
\end{lstlisting}

Der Scan wird kurzen Delay gestartet, um sicherzugehen, dass alles vollständig geladen ist.
Dabei werden erfolgreich gescannte Barcodes und QR-Codes als Liste gespeichert.
Wir verwenden aber hier immer nur den ersten erfolgreichen Code innerhalb der Liste.

\begin{lstlisting}[caption=QR-Code gefunden, label=qr_found]
  body: MobileScanner(
        startDelay: true,
        controller: cameraController,
        onDetect: (capture) {
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty && !_screenOpened) {
            final String code = barcodes.first.rawValue ?? "---";
            debugPrint('QRCode found! $code');
\end{lstlisting}

Nun wird überprüft, ob der gescannte QR-Code auch einem gültigen Format entspricht, sonst wird er abgelehnt.
Der Benutzer wird darüber in einer SnackBar informiert.

\begin{lstlisting}[caption={QR-Code Check}]
  try {
    final Map<String, dynamic> data = jsonDecode(code);

    // Ueberpruefen, ob der Namespace 'payero' ist
    if (data['namespace'] != 'payero') {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Ungueltiger QR-Code')),
      );
      return; // Beenden der Funktion, wenn der Namespace nicht stimmt
    }

    // Ueberpruefen, ob der 'amount' zu einem double konvertiert werden kann
    final double? amount = double.tryParse(data['amount'].toString());
    if (amount == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Ungueltiger QR-Code')),
      );
      return; // Beenden der Funktion, wenn der amount ungueltig ist
    }

    final String formattedAmount = amount.toStringAsFixed(2);

    ScaffoldMessenger.of(context).removeCurrentSnackBar();

    // Weitermachen mit gueltigen Daten
    _screenOpened = true;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => FoundCodeScreen(
          screenClosed: _screenWasClosed,
          userId: userId,
          value: formattedAmount,
        ),
      ),
    ).then((_) => _screenWasClosed());
  } catch (e) {
    debugPrint("Error while scanning: ${e.toString()}");
    // Generische Fehlermeldung anzeigen
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Ungueltiger QR-Code')),
    );
  }
\end{lstlisting}

Das gültige Format eines QR-Codes ist in JSON und sieht so aus:

\begin{lstlisting}[caption={Gültiger QR-Code}]
  {
   "namespace":"payero",
   "userID":"user1",
   "amount":"3.00"
  }
\end{lstlisting}

Der dazugehörige QR-Code sieht dann so aus:

\begin{figure}[H]
  \centering
  \includegraphics[width=.8\textwidth, height=.8\textwidth]{qr-code.png}
  \caption{Gültiger QR-Code}
\end{figure}

Beim Anzeigen des Betrages innerhalb der App wird auf jeder Page ausschließlich der Betrag mit zwei Nachkommastellen angezeigt.
Dies ist unabhängig davon, ob der \glqq amount\grqq{} im QR-Code Nachkommastellen beinhaltet, und dient ausschließlich kosmetischer Eigenschaften, verbessert aber das Nutzererlebnis aufgrund der immer gleichen Formatierung.
Dies betrifft auch die QR-Codes, welche im Hauptmenü eingescannt werden können.
Um zu verhindern, dass immer weiter gescannt wird, wenn ein QR-Code gefunden wurde, wird ein bool Flag gesetzt über den Parameter \glqq \_screenOpened\grqq{}.
Anschließend wird bei einem gültigen QR-Code zu einer neuen Page gewechselt.
Diese zeigt den zu bezahlenden Betrag an und einen Button mit dem bezahlt werden kann.
Durch Klick auf den Button öffnet sich das BrainTree DropinUI.

\section{Bezahlintegration mit Braintree}

Im BrainTree DropinUI kann die Bezahlmethode ausgewählt werden.
Es wird momentan PayPal, Kreditkarte (VISA, Mastercard) und GooglePay angeboten.
ApplePay ist auch implementiert, aber es muss noch eine gültige Merchant-ID angegeben werden, um die Funktion zu aktivieren.
Diese Merchant-ID ist ausschließlich mit einem Abonnement des Apple Developer Programm erhältlich.
Des Weiteren wird ausschließlich der Sandbox Account von Braintree verwendet, da es als Privatperson ohne Unternehmen mit gültiger Umsatzsteueridentifikationsnummer und Angabe der Besitzanteile an der Firma bzw. der Position innerhalb dieser nicht möglich ist einen Produktivaccount zu bekommen aufgrund \S\S 10 - 17 des Geldwäschegesetzes.
Wenn man in Besitz eines gültigen Braintree Produktivaccount ist, muss man nur den \glqq tokenizationKey\grqq{} austauschen, um die App produktiv zu schalten.

\begin{lstlisting}[caption={BrainTree Bezahlmethoden}]
  class _FoundCodeScreenState extends State<FoundCodeScreen> {
  String currency = "EUR";

  void startBraintreeCheckout() async {
    var request = BraintreeDropInRequest(
      tokenizationKey:
          'sandbox_d53t3dpq_8fxhdjy2nrd33mtm', // Ersetzen mit echtem tokenizationKey aus BrainTree Account
      collectDeviceData: true,
      paypalRequest: BraintreePayPalRequest(
        amount: widget.value,
        displayName: 'Payero',
        currencyCode: currency,
      ),
      googlePaymentRequest: BraintreeGooglePaymentRequest(
        totalPrice: widget.value,
        currencyCode: currency,
        billingAddressRequired: false,
      ),
      applePayRequest: BraintreeApplePayRequest(
        paymentSummaryItems: [
          ApplePaySummaryItem(
              label: 'Payero',
              amount: double.parse(widget.value),
              type: ApplePaySummaryItemType.final_)
        ],
        displayName: 'Payero',
        currencyCode: currency,
        countryCode: 'DE',
        merchantIdentifier:
            'merchant.com.example.mobile_computing_payment_app', // Ersetzen mit echtem Apple Pay Merchant Identifier
        supportedNetworks: [
          ApplePaySupportedNetworks.visa,
          ApplePaySupportedNetworks.masterCard,
          ApplePaySupportedNetworks.amex
        ],
      ),
      // Weitere Optionen und Konfigurationen
    );  
\end{lstlisting}

Mit dem Auswählen der Bezahlmethode wird überprüft, ob eine Internetverbindung besteht.
Dann erst erfolgt die vollständige Bezahlung und die Übermittlung der Zahldaten an den Backendserver.
Hier wird der Benutzer wieder über Fehler oder das weitere Vorgehen in einer SnackBar informiert.
Wenn also keine Internetverbindung besteht, oder Benutzer den Bezahlvorgang abbricht, um zum Beispiel noch die Bezahlmethode zu wechseln, wird dieser in einer Snackbar darüber informiert.
Bezahlt der Benutzer nun wird er über die Verarbeitung des Bezahlvorganges mit seiner jeweiligen Zahlmethode in einer SnackBar informiert.
Anschließend landet der Benutzer auf einer Abschlussseite, wenn der Bezahlvorgang erfolgreich war.

\begin{lstlisting}[caption={Durchführung des Bezahlvorganges}]
  try {
    BraintreeDropInResult? result = await BraintreeDropIn.start(request);
    if (result != null) {
      // print(
      //     'Zahlung erfolgreich: ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(
                'Bearbeite Zahlungsvorgang mit ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}'),
            duration: const Duration(seconds: 2)),
      );

      // ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      //   content: Text(
      //       'Zahlung erfolgreich: ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}'),
      //   duration: const Duration(seconds: 2),
      // ));

      await Future.delayed(const Duration(seconds: 3));

      Navigator.push(context,
          MaterialPageRoute(builder: (_) => EndScreen(value: widget.value)));

      // Weitere Aktionen nach erfolgreicher Zahlung

      try {
        if (widget.userId == "") {
          throw Exception("userId is empty");
        }

        final response = await http.post(
            Uri.parse("$SERVER_URL/${widget.userId}/transact"),
            body: jsonEncode(<String, String>{
              "receiver": "mobile_computing_payment_app",
              "amount": '${double.parse(widget.value) * -1}',
              "currency": currency,
              "message": "${result.paymentMethodNonce.description}"
            }));

        debugPrint("response: " + response.body);

        if (response.statusCode != 200) {
          throw Exception('Failed to save transaction.' + response.body);
        }
      } catch (e) {
        debugPrint(e.toString());
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text('Zahlungsvorgang abgebrochen'),
          duration: Duration(seconds: 2)));
    }
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
            'Zahlungsvorgang abgebrochen. Stellen Sie sicher, dass Sie mit dem Internet verbunden sind. \n\n Fehler: $e')));
  }
}
\end{lstlisting}

Auf dieser Abschlussseite \glqq end\_screen.dart\grqq{} wird der Benutzer über den erfolgreich bezahlten Betrag informiert.
Anschließend kann er noch den Vorgang mit dem \glqq Fertig\grqq{} Button abschließen, um wieder im Hauptmenü zu landen.
Damit kann ein neuer Bezahlvorgang gestartet werden.
Der \glqq Zurück\grqq{} Button ist auf dieser Seite extra unterbunden, damit ein Anwender nicht doch aus Versehen wieder auf der Bezahlseite landet und den Betrag erneut bezahlt.
Dabei ist auch der Hardware Button unter Android mit eingeschlossen, da sonst auch bei Deaktivieren in der Software ein zurück über diesen möglich ist.
Dies geschieht bei Android mit \glqq onWillPop\grqq{}.

\begin{lstlisting}[caption={EndScreen bei erfolgreichem Bezahlvorgang}]
  class EndScreen extends StatelessWidget {
  final String value;

  const EndScreen({Key? key, required this.value}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
        onWillPop: () async => false, // Verhindert das Zurueckgehen
        child: Scaffold(
            appBar: const PayeroHeader(
              showBackButton: false,
            ),
            body: Stack(children: [
              Column(children: [
                Expanded(
                  child: Container(
                    padding: const EdgeInsets.only(
                        bottom: 30, top: 80, left: 30, right: 30),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Zahlung erfolgreich ausgefuehrt',
                            style: TextStyle(fontSize: 20)),
                        Text('\$ value \euro',
                            style: const TextStyle(
                                fontSize: 40, fontWeight: FontWeight.bold)),
                        SvgPicture.asset(
                          'assets/images/payero-illustration.svg',
                          fit: BoxFit.fitWidth,
                          alignment: Alignment.center,
                          // height: 50.0,
                        )
                      ],
                    ),
                  ),
                ),
                Container(
                    margin:
                        const EdgeInsets.only(left: 30, right: 30, bottom: 30),
                    child: Column(children: [
                      PayeroButton(
                          text: "Fertig",
                          onClick: () => {
                                Navigator.push(
                                    context,
                                    MaterialPageRoute(
                                      builder: (_) => const MainScreen(),
                                    ))
                              }),
                    ]))
              ]),
            ])));
  }
}
\end{lstlisting}

\section{Backend}

Zur Realisierung der Transaktionshistorie wurde ein einfaches Backend mit Node.js entwickelt.
Dieses kann später erweitert werden und die Grundlage für die Umsetzung einer Authentifizierung und weiterer Features darstellen.
Es wird das Framework Next.js eingesetzt, da dies für die Autoren keine große Einarbeitungszeit erforderte.
Mithilfe von diesem können Applikation mit React.js umgesetzt werden, aber auch REST-API's implementiert werden.
Als Datenbank wird eine einfache SQLite-Datenbank verwendet, da diese als Datei gesichert werden kann.
Diese wird mithilfe des Frameworks Prisma angebunden, welches auf dem Konzept des Object-Relational-Mappings basiert.
Das heißt, dass mithilfe von Prisma eine Datenbankstruktur in Form der Datei ./backend/prisma/schema.prisma definiert wird.
Prisma erstellt daraufhin eine Tabellenstruktur und sichert diese in der SQLite-Datenbank ./backend/prisma/database.db.
Der Prisma-Client wird dann innerhalb der Next.js-Anwendung aufgerufen und erlaubt die Abfrage der Datenbank in einer objekt-notierten Form, die ebenfalls bereits alle Relationen enthält.
Zur Umsetzung des Datenbank-Schemas wurde das in Abbildung \ref{fig:er_diagramm} dargestellte Entity-Relationship-Diagramm in Chen-Notation entworfen.
Ein Benutzer kann mehrere Transkationen empfangen haben, aber auch durchgeführt haben.
Eine Transaktion hat immer einen Empfänger und einen Absender.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{er-diagramm.png}
  \label{fig:er_diagramm}
  \caption{Darstellung des Entity-Relationship-Diagramms für die Datenbank}
\end{figure}

Als kleine Abweichung von diesem ER-Diagramm wird das eigentliche Schema so umgesetzt, dass nur die Relation Absender-Transaction abgebildet wird.
Der Empfänger einer Transaktion wird als freies String-Feld umgesetzt, da dieser so frei definiert werden kann.
Solange die Transaktionen im Rahmen des Projekts einen fixen Empfänger erreichen, ist man so flexibler in der Handhabung und kann einen Dummy-Empfänger wie z.B. die E-Mail-Adresse des Braintree-Accounts angeben.
\\
Das Backend wird einem Docker-Container gehostet, welcher mithilfe von Docker-Compose deployed werden kann.
\\
In Abbildung \ref{fig:apidesign} wird dargestellt, welche API-Endpunkte umgesetzt werden sollten:

\begin{figure}[H]
  \centering
  \includegraphics[width=.8\textwidth]{api-design.png}
  \label{fig:apidesign}
  \caption{Darstellung der API-Endpunkte für das Backend}
\end{figure}

Zunächst ist ein Endpunkt zur Registrierung vorgesehen, welcher dazu dient den Benutzer mithilfe eines Nicknames und einer E-Mail-Adresse zu registrieren.
Sofern ein Benutzer bereits existiert wird ein weiterer in der Datenbank angelegt, da hier keine Überprüfung stattfindet.
Dieser bekommt eine individuelle UUID zugeteilt und wird anschließend in der Datenbank gesichert.\\
Es wurde an dieser Stelle bewusst auf eine reale Authentifizierung mittels bspw. Passwort und Session-ID oder JWT verzichtet, da so im Rahmen des Projekts auch auf das clientseitige Session-Handling verzichtet werden konnte.
So konnte an anderen Bestandteilen der App gearbeitet werden.\\
Die UUID wird in den SharedPreferences der App gesichert und dient der Abfrage der weiteren Endpunkte.
Über den Endpunkt /{uuid}/history kann die Transaktionshistorie abgefragt werden.
Diese enthält alle Informationen über vergangene Transaktionen wie bspw. Betrag, Währung, Zeitpunkt und Empfänger.
Eine Transaktion wird clientseitig durch das Aufrufen des POST-Endpunkts /{uuid}/transact gesichert, sofern eine Zahlung komplett abgeschlossen wurde.
An diesen Endpunkt werden die o.g. Daten übergeben und diese so in der Datenbank gesichert.\\
Der weitere Endpunkt /{uuid}/qr dient der Generierung eines individuellen QR-Codes, welcher jeweils für einen Benutzer generiert wird. Der QR-Code enthält einen vordefinierten Betrag, mithilfe dessen die Transaktionen gestartet werden können.
Als Weiterentwicklung der Applikation könnte so später eine echte Peer-To-Peer-Überweisung ermöglicht werden, sodass die scannende Person an denjenigen überweist, der den QR-Code mit seiner kodierten ID präsentiert.\\
Der QR-Code kodiert folgende Informationen in Form eines JSON-Objekts:
\begin{lstlisting}[caption={Vom Backend generierte Notation für den QR-Code}]
  { namespace: "payero", id:{UUID}, amount: "2.0" }
\end{lstlisting}
Mithilfe des Namespace-Attributes kann geprüft werden, ob der QR-Code für Payero vorgesehen ist.
Ebenfalls enthält der QR-Code die Benutzer-UUID und den Betrag als Gleitkommazahl.