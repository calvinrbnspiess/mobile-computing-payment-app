%!TEX root = ../dokumentation.tex

\chapter{Implementierung}

Dieses Kapitel beinhaltet sämtliche Implementierungen und Features in der App.
Dabei werden benutzte Libraries und Code aus der App gezeigt.

\section{App}

Hier screenshots und erklärung

\section{QR-Code Scanner}

Zum Erkennen und Scannen der QR-Codes wird die Library \glqq mobile\_scanner\grqq{} in der Version \glqq 3.5.2\grqq{} genutzt.
Diese arbeitet sowohl unter iOS als auch Android zuverlässig.
Die Integration findet in der \glqq qr\_code\_scan\_screen.dart\grqq{} Datei statt.
Es wird hierzu die Klasse \glqq \_QRScanScreenState\grqq{} erstellt in welcher die Funktionen der Library implementiert werden.
Unter anderem ist hier die Steuerung der Kamera, das Umschalten zwischen Front- und Rückkamera und die Steuerung des Kamerablitzes möglich.

\begin{lstlisting}[caption=Kamerasteuerung, label=cam_ctrl]
	appBar: PayeroHeader(showBackButton: true, actions: [
        IconButton(
          color: Colors.white,
          icon: ValueListenableBuilder(
            valueListenable: cameraController.torchState,
            builder: (context, state, child) {
              switch (state as TorchState) {
                case TorchState.off:
                  return const Icon(Icons.flash_off, color: Colors.grey);
                case TorchState.on:
                  return const Icon(Icons.flash_on, color: Colors.yellow);
              }
            },
          ),
          iconSize: 32.0,
          onPressed: () => cameraController.toggleTorch(),
        ),
        IconButton(
          color: Colors.white,
          icon: ValueListenableBuilder(
            valueListenable: cameraController.cameraFacingState,
            builder: (context, state, child) {
              switch (state as CameraFacing) {
                case CameraFacing.front:
                  return const Icon(Icons.camera_front, color: Colors.grey);
                case CameraFacing.back:
                  return const Icon(Icons.camera_rear, color: Colors.grey);
              }
            },
          ),
          iconSize: 32.0,
          onPressed: () => cameraController.switchCamera(),
        )
      ])
\end{lstlisting}

Der Scan wird mit einer kurzen Verzögerung gestartet, um sicherzustellen, dass alles vollständig geladen ist.
Die erfolgreich gescannten Barcodes und QR-Codes werden als Liste gespeichert.
Wir verwenden hier aber immer nur den ersten erfolgreichen Code in der Liste.

\begin{lstlisting}[caption=QR-Code gefunden, label=qr_found]
  body: MobileScanner(
        startDelay: true,
        controller: cameraController,
        onDetect: (capture) {
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty && !_screenOpened) {
            final String code = barcodes.first.rawValue ?? "---";
            debugPrint('QRCode found! $code');
\end{lstlisting}

Nun wird geprüft, ob der gescannte QR-Code ein gültiges Format hat, andernfalls wird er abgelehnt.
Der Benutzer wird darüber in einer SnackBar informiert.

\begin{lstlisting}[caption={QR-Code Check}]
  try {
    final Map<String, dynamic> data = jsonDecode(code);

    // Ueberpruefen, ob der Namespace 'payero' ist
    if (data['namespace'] != 'payero') {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Ungueltiger QR-Code')),
      );
      return; // Beenden der Funktion, wenn der Namespace nicht stimmt
    }

    // Ueberpruefen, ob der 'amount' zu einem double konvertiert werden kann
    final double? amount = double.tryParse(data['amount'].toString());
    if (amount == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Ungueltiger QR-Code')),
      );
      return; // Beenden der Funktion, wenn der amount ungueltig ist
    }

    final String formattedAmount = amount.toStringAsFixed(2);

    ScaffoldMessenger.of(context).removeCurrentSnackBar();

    // Weitermachen mit gueltigen Daten
    _screenOpened = true;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => FoundCodeScreen(
          screenClosed: _screenWasClosed,
          userId: userId,
          value: formattedAmount,
        ),
      ),
    ).then((_) => _screenWasClosed());
  } catch (e) {
    debugPrint("Error while scanning: ${e.toString()}");
    // Generische Fehlermeldung anzeigen
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Ungueltiger QR-Code')),
    );
  }
\end{lstlisting}

Das gültige Format eines QR-Codes ist JSON und sieht wie folgt aus:

\begin{lstlisting}[caption={Gültiger QR-Code}]
  {
   "namespace":"payero",
   "userID":"user1",
   "amount":"3.00"
  }
\end{lstlisting}

Der entsprechende QR-Code sieht dann so aus:

\begin{figure}[H]
  \centering
  \includegraphics[width=.8\textwidth, height=.8\textwidth]{qr-code.png}
  \caption{Gültiger QR-Code}
\end{figure}

Bei der Anzeige des Betrags innerhalb der App wird der Betrag auf jeder Seite nur mit zwei Nachkommastellen angezeigt.
Dies ist unabhängig davon, ob der \glqq amount\grqq{} im QR-Code Nachkommastellen enthält oder nicht, und dient ausschließlich kosmetischen Zwecken, verbessert aber aufgrund der immer gleichen Formatierung das Nutzererlebnis.
Dies gilt auch für die QR-Codes, die im Hauptmenü gescannt werden können.
Um zu verhindern, dass immer weiter gescannt wird, wenn ein QR-Code gefunden wurde, wird über den Parameter \glqq \_screenOpened\grqq{} ein Bool-Flag gesetzt.
Danach wird bei einem gültigen QR-Code auf eine neue Seite gewechselt.
Diese zeigt den zu zahlenden Betrag und einen Button, mit dem bezahlt werden kann.
Ein Klick auf den Button öffnet das BrainTree Dropin-UI.

\section{Bezahlintegration mit Braintree}

Die Zahlungsmethode kann im BrainTree Dropin-UI ausgewählt werden.
Derzeit werden PayPal, Kreditkarte (VISA, Mastercard) und GooglePay angeboten.
ApplePay ist ebenfalls implementiert, jedoch muss eine gültige Merchant-ID angegeben werden, um die Funktion zu aktivieren.
Diese Merchant-ID ist nur mit einer Mitgliedschaft im Apple Developer Program erhältlich.
Darüber hinaus wird ausschließlich der Sandbox-Account von Braintree genutzt, da es als Privatperson ohne gültige Umsatzsteuer-Identifikationsnummer und wahrheitsgemäße Angaben zu den Eigentumsverhältnissen oder der Stellung im Unternehmen gemäß \S\S 10 bis 17 Geldwäschegesetz nicht möglich ist, einen Produktiv-Account zu erhalten.
Ist man im Besitz eines gültigen Braintree-Produktivaccounts, muss lediglich der \glqq tokenizationKey\grqq{} ausgetauscht werden, um die Anwendung produktiv zu schalten.

\begin{lstlisting}[caption={BrainTree Bezahlmethoden}]
  class _FoundCodeScreenState extends State<FoundCodeScreen> {
  String currency = "EUR";

  void startBraintreeCheckout() async {
    var request = BraintreeDropInRequest(
      tokenizationKey:
          'sandbox_d53t3dpq_8fxhdjy2nrd33mtm', // Ersetzen mit echtem tokenizationKey aus BrainTree Account
      collectDeviceData: true,
      paypalRequest: BraintreePayPalRequest(
        amount: widget.value,
        displayName: 'Payero',
        currencyCode: currency,
      ),
      googlePaymentRequest: BraintreeGooglePaymentRequest(
        totalPrice: widget.value,
        currencyCode: currency,
        billingAddressRequired: false,
      ),
      applePayRequest: BraintreeApplePayRequest(
        paymentSummaryItems: [
          ApplePaySummaryItem(
              label: 'Payero',
              amount: double.parse(widget.value),
              type: ApplePaySummaryItemType.final_)
        ],
        displayName: 'Payero',
        currencyCode: currency,
        countryCode: 'DE',
        merchantIdentifier:
            'merchant.com.example.mobile_computing_payment_app', // Ersetzen mit echtem Apple Pay Merchant Identifier
        supportedNetworks: [
          ApplePaySupportedNetworks.visa,
          ApplePaySupportedNetworks.masterCard,
          ApplePaySupportedNetworks.amex
        ],
      ),
      // Weitere Optionen und Konfigurationen
    );  
\end{lstlisting}

Bei der Auswahl der Zahlungsmethode wird geprüft, ob eine Internetverbindung besteht.
Erst dann erfolgt die vollständige Bezahlung und die Übermittlung der Zahlungsdaten an den Backend-Server.
Auch hier wird der Benutzer in einer SnackBar über Fehler oder das weitere Vorgehen informiert.
Besteht also keine Internetverbindung oder bricht der Benutzer den Bezahlvorgang ab, um z.B. noch die Bezahlmethode zu wechseln, wird er in einer SnackBar darüber informiert.
Bezahlt der Benutzer nun, wird er in einer SnackBar über die Verarbeitung des Bezahlvorgangs mit seiner jeweiligen Bezahlmethode informiert.
Wenn der Bezahlvorgang erfolgreich war, wird der Benutzer auf eine Abschlussseite weitergeleitet.

\begin{lstlisting}[caption={Durchführung des Bezahlvorganges}]
  try {
    BraintreeDropInResult? result = await BraintreeDropIn.start(request);
    if (result != null) {
      // print(
      //     'Zahlung erfolgreich: ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(
                'Bearbeite Zahlungsvorgang mit ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}'),
            duration: const Duration(seconds: 2)),
      );

      // ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      //   content: Text(
      //       'Zahlung erfolgreich: ${result.paymentMethodNonce.typeLabel} ${result.paymentMethodNonce.description}'),
      //   duration: const Duration(seconds: 2),
      // ));

      await Future.delayed(const Duration(seconds: 3));

      Navigator.push(context,
          MaterialPageRoute(builder: (_) => EndScreen(value: widget.value)));

      // Weitere Aktionen nach erfolgreicher Zahlung

      try {
        if (widget.userId == "") {
          throw Exception("userId is empty");
        }

        final response = await http.post(
            Uri.parse("$SERVER_URL/${widget.userId}/transact"),
            body: jsonEncode(<String, String>{
              "receiver": "mobile_computing_payment_app",
              "amount": '${double.parse(widget.value) * -1}',
              "currency": currency,
              "message": "${result.paymentMethodNonce.description}"
            }));

        debugPrint("response: " + response.body);

        if (response.statusCode != 200) {
          throw Exception('Failed to save transaction.' + response.body);
        }
      } catch (e) {
        debugPrint(e.toString());
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text('Zahlungsvorgang abgebrochen'),
          duration: Duration(seconds: 2)));
    }
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
            'Zahlungsvorgang abgebrochen. Stellen Sie sicher, dass Sie mit dem Internet verbunden sind. \n\n Fehler: $e')));
  }
}
\end{lstlisting}

Auf dieser Abschlussseite \glqq end\_screen.dart\grqq{} wird der Benutzer über den erfolgreich bezahlten Betrag informiert.
Anschließend kann er den Vorgang mit dem Button \glqq Fertig\grqq{} abschließen, um wieder ins Hauptmenü zu gelangen.
Ein neuer Bezahlvorgang kann gestartet werden.
Der \glqq Zurück\grqq{} Button ist auf dieser Seite extra deaktiviert, damit ein Benutzer nicht aus Versehen wieder auf der Bezahlseite landet und den Betrag erneut bezahlt.
Dazu gehört auch der Hardware-Button unter Android, der auf dieser Seite deaktiviert ist.
Ansonsten wäre auch bei ausschließlicher Deaktivierung in der Software ein Zurück über diesen Hardware-Button möglich.
Dies geschieht bei Android mit \glqq onWillPop\grqq{}.

\begin{lstlisting}[caption={EndScreen bei erfolgreichem Bezahlvorgang}]
  class EndScreen extends StatelessWidget {
  final String value;

  const EndScreen({Key? key, required this.value}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
        onWillPop: () async => false, // Verhindert das Zurueckgehen
        child: Scaffold(
            appBar: const PayeroHeader(
              showBackButton: false,
            ),
            body: Stack(children: [
              Column(children: [
                Expanded(
                  child: Container(
                    padding: const EdgeInsets.only(
                        bottom: 30, top: 80, left: 30, right: 30),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Zahlung erfolgreich ausgefuehrt',
                            style: TextStyle(fontSize: 20)),
                        Text('\$ value \euro',
                            style: const TextStyle(
                                fontSize: 40, fontWeight: FontWeight.bold)),
                        SvgPicture.asset(
                          'assets/images/payero-illustration.svg',
                          fit: BoxFit.fitWidth,
                          alignment: Alignment.center,
                          // height: 50.0,
                        )
                      ],
                    ),
                  ),
                ),
                Container(
                    margin:
                        const EdgeInsets.only(left: 30, right: 30, bottom: 30),
                    child: Column(children: [
                      PayeroButton(
                          text: "Fertig",
                          onClick: () => {
                                Navigator.push(
                                    context,
                                    MaterialPageRoute(
                                      builder: (_) => const MainScreen(),
                                    ))
                              }),
                    ]))
              ]),
            ])));
  }
}
\end{lstlisting}

\section{Backend}
